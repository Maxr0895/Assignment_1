# Presigned Upload Integration Summary

## ✅ Changes Complete

The presigned S3 upload flow has been integrated into the existing "Upload Meeting" UI. The standalone test page has been removed.

## 📝 Code Changes

### 1. Frontend Changes (`public/app.js`)

#### **handleUpload() - Complete Rewrite**

**Before:**
```javascript
async handleUpload(e) {
  e.preventDefault();
  const formData = new FormData();
  // ... create FormData with file
  
  const response = await this.apiFetch("/v1/meetings", {
    method: "POST",
    body: formData,
  });
  // ... handle response
}
```

**After (3-step presigned flow):**
```javascript
async handleUpload(e) {
  e.preventDefault();
  const file = fileInput.files[0];
  
  // Step 1: Get presigned upload URL
  const presignResponse = await this.apiFetch("/v1/files/presign-upload", {
    method: "POST",
    body: JSON.stringify({
      fileName: file.name,
      fileType: file.type
    })
  });
  const { uploadUrl, key, meetingId } = await presignResponse.json();
  
  // Step 2: Upload directly to S3 with progress tracking
  await this.uploadToS3WithProgress(uploadUrl, file, (progress) => {
    progressBar.value = progress;
    progressText.textContent = `${progress}%`;
  });
  
  // Step 3: Register the meeting with sourceKey
  const registerResponse = await this.apiFetch("/v1/meetings", {
    method: "POST",
    body: JSON.stringify({
      sourceKey: key,
      title: titleInput.value || `Meeting ${new Date().toISOString().split('T')[0]}`
    })
  });
}
```

#### **New Method: uploadToS3WithProgress()**

```javascript
uploadToS3WithProgress(url, file, onProgress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percentComplete = Math.round((e.loaded / e.total) * 100);
        onProgress(percentComplete);
      }
    });
    
    xhr.addEventListener('load', () => {
      if (xhr.status === 200) {
        resolve();
      } else {
        reject(new Error(`S3 upload failed with status ${xhr.status}`));
      }
    });
    
    xhr.open('PUT', url);
    xhr.setRequestHeader('Content-Type', file.type); // MUST match presigned URL
    xhr.send(file);
  });
}
```

### 2. Frontend UI Changes (`public/index.html`)

**Added progress bar to upload form:**

```html
<div id="upload-progress-container" class="form-group hidden">
  <label>Upload Progress:</label>
  <progress id="upload-progress" value="0" max="100" style="width: 100%; height: 25px;"></progress>
  <span id="upload-progress-text">0%</span>
</div>
```

### 3. Backend Changes (`src/routes/meetings.ts`)

#### **POST /v1/meetings - Updated to Handle Both Flows**

**Added imports:**
```typescript
import express from 'express';
```

**Before:**
```typescript
router.post('/', authRequired, upload.single('file'), async (req, res) => {
  // Only handled multipart upload
});
```

**After:**
```typescript
router.post('/', authRequired, express.json(), async (req, res, next) => {
  // Flow 1: Presigned upload (JSON with sourceKey) - PREFERRED
  if (req.body && req.body.sourceKey) {
    const { sourceKey, title } = req.body;
    
    // Extract meetingId from sourceKey: meetings/{meetingId}/{fileName}
    const keyParts = sourceKey.split('/');
    const meetingId = keyParts[1];
    const fileName = keyParts.slice(2).join('/');
    
    // Create meeting in DynamoDB
    await ddbService.createMeeting({
      id: meetingId,
      title,
      status: 'uploaded',
      s3Prefix: `meetings/${meetingId}`,
      created_at: new Date().toISOString(),
      originalFilename: fileName,
      userId: req.user.sub
    });
    
    return res.json({ meetingId, message: 'Meeting registered successfully' });
  }
  
  // Flow 2: Multipart upload (fallback for compatibility)
  upload.single('file')(req, res, async (err) => {
    // ... existing multipart logic unchanged
  });
});
```

**Key Differences:**

| Aspect | Presigned Flow | Multipart Flow (Fallback) |
|--------|---------------|---------------------------|
| Request Body | JSON `{ sourceKey, title }` | FormData with file |
| File Handling | Already in S3 | Upload to S3 from server |
| meetingId | Extracted from sourceKey | Generated by server |
| Performance | ✅ Direct S3 upload | ❌ Goes through server |
| Progress | ✅ Client-side tracking | ❌ No progress feedback |

## 🔄 Upload Flow Diagram

### New Presigned Flow (Default):
```
1. Client → POST /v1/files/presign-upload → Server
   ↓ Returns: { uploadUrl, key, meetingId }

2. Client → PUT {file} → S3 (with progress tracking)
   ↓ XMLHttpRequest with Content-Type header

3. Client → POST /v1/meetings { sourceKey, title } → Server
   ↓ Creates DynamoDB entry
   
✅ Complete
```

### Fallback Multipart Flow:
```
1. Client → POST /v1/meetings (FormData with file) → Server
   ↓ Server uploads to S3
   ↓ Creates DynamoDB entry
   
✅ Complete
```

## 📋 Files Changed

### Modified:
1. ✅ `public/app.js` - Updated `handleUpload()`, added `uploadToS3WithProgress()`
2. ✅ `public/index.html` - Added progress bar UI
3. ✅ `src/routes/meetings.ts` - Updated to handle both sourceKey and multipart
4. ✅ `README.md` - Added CORS configuration section

### Deleted:
1. ✅ `public/presigned-upload-test.html` - Removed standalone test page

## 🌐 CORS Configuration Required

**S3 bucket CORS must be configured for presigned uploads to work:**

```json
[
  {
    "AllowedHeaders": ["*"],
    "AllowedMethods": ["GET", "PUT", "POST"],
    "AllowedOrigins": ["http://localhost:8080", "https://your-domain.com"],
    "ExposeHeaders": ["ETag"],
    "MaxAgeSeconds": 3000
  }
]
```

**Critical:** The `Content-Type` header sent by the client MUST match the `fileType` specified when requesting the presigned URL.

## ✅ Testing

1. **Login** to the app
2. **Click "Upload Meeting"**
3. **Select a video file**
4. Watch the **progress bar** fill up as it uploads to S3
5. See **"Meeting registered successfully"** message

## 🔑 Key Implementation Details

### Content-Type Matching
```javascript
// Frontend: Request presigned URL with file.type
fetch('/v1/files/presign-upload', {
  body: JSON.stringify({
    fileName: file.name,
    fileType: file.type  // e.g., "video/mp4"
  })
});

// Frontend: Upload to S3 with SAME Content-Type
xhr.setRequestHeader('Content-Type', file.type); // MUST match!
xhr.send(file);

// Backend: Generate presigned URL with Content-Type
const command = new PutObjectCommand({
  Bucket: this.bucket,
  Key: key,
  ContentType: contentType  // Enforced by S3
});
```

### sourceKey Format
```
meetings/{uuid}/{fileName}

Example:
meetings/550e8400-e29b-41d4-a716-446655440000/recording.mp4
```

### Backend Extraction
```typescript
const keyParts = sourceKey.split('/');
// keyParts[0] = "meetings"
// keyParts[1] = "550e8400-e29b-41d4-a716-446655440000" (meetingId)
// keyParts[2+] = "recording.mp4" (fileName)
```

## 🚀 Benefits

1. ✅ **Better Performance** - Direct S3 uploads, no server bottleneck
2. ✅ **Progress Tracking** - Real-time upload progress with XMLHttpRequest
3. ✅ **Reduced Server Load** - File bytes never touch application server
4. ✅ **Backward Compatible** - Multipart fallback still works
5. ✅ **Scalable** - Handles large files without server memory issues

## 📊 Exact Code Diffs

### `public/app.js` - handleUpload() method
**Lines changed:** 315-363 → 315-431 (replaced + added new method)
- Replaced FormData upload with 3-step presigned flow
- Added XMLHttpRequest-based S3 upload with progress callback
- Shows progress bar and status messages

### `src/routes/meetings.ts` - POST /v1/meetings
**Lines changed:** 1-70 → 1-117 (refactored)
- Added `express.json()` middleware
- Check for `sourceKey` in body first (presigned flow)
- Extract meetingId from sourceKey path
- Fall back to multipart if no sourceKey
- Both flows create same DynamoDB structure

### `public/index.html` - Upload form
**Lines added:** 131-135
- Progress bar container (initially hidden)
- Shows during S3 upload

### `README.md` - CORS section
**Lines added:** 231-272
- Complete S3 CORS configuration guide
- Explanation of Content-Type enforcement
- Troubleshooting tips

## ⚠️ Important Notes

1. **CORS must be configured on S3** - See README for exact configuration
2. **Content-Type must match** - Client header must equal presign request fileType
3. **Presigned URLs expire** - Default 15 minutes (900 seconds)
4. **Fallback exists** - Multipart upload still works if presigned fails
5. **No breaking changes** - Existing API calls continue to work

